предстоит реализовать аналог контейнера std::unordered_map — ассоциативный массив на основе хеш-таблицы, который поддерживает отображение ключ -> значение, т.е. в соответствие каждому ключу ставится единственное значение, а все ключи уникальны. Вы должны написать шаблон HashMap, который параметризуется типом ключа, типом значения и типом «хешера», иными словами, следующее:
template<class KeyType, class ValueType, class Hash = std::hash<KeyType> > class HashMap;

Ваш класс должен содержать следующие конструкторы и методы:
1) Конструктор по умолчанию.
2) Конструктор, принимающий итераторы на начало и конец (точнее, следующий за концом) последовательности, каждый элемент которой представляет собой std::pair<ключ, значение>.
3) Конструктор, принимающий std::initializer_list описанных выше пар.
4) Все конструкторы также должны поддерживать возможность передачи объекта хешера (т.е. имеющего тип Hash) последним аргументом. В случае же, если таковой не передается, то используйте сконструированный по умолчанию.
5) Методы size и empty, которые должны быть константными, и которые возвращают количество элементов в таблице и пуста ли она соответственно.
6) Константный метод hash_function, который возвращает используемый таблицей хешер по значению.
7) Метод insert, который принимает std::pair<ключ, значение> и добавляет в таблицу связь ключ -> значение. Если данный ключ уже имеется в таблице, то метод не должен ничего делать.
8) Метод erase, который принимает ключ и удаляет соответствующую пару (ключ, значение) из таблицы. Если искомого ключа нет, то метод не должен ничего делать.
9) Ваш класс должен предоставлять типы iterator и const_iterator, соответствующие итератору и константному итератору, с помощью которых можно было бы просмотреть содержимое таблицы, а также соответствующие методы begin и end для обоих типов итераторов, возвращающих итератор на начало контейнера и следующий за последним (как все контейнеры стандартной библиотеки). Итератор должен адресовывать значения типа std::pair<const KeyType, ValueType>&, а константный итератор — типа const std::pair<const KeyType, ValueType>&. Таким образом, с помощью обычного итератора можно изменять только значения в таблице (но не ключи), а с помощью константного итератора модификации невозможны совсем.
10) Обратите внимание, что итерирование по всей таблице должно занимать линейное время по числу вставленных элементов. Однако порядок, в котором перебираются элементы таблицы, может быть произвольным.
11) Итераторы должны быть, по крайней мере, forward — грубо говоря, поддерживать конструирование, инкремент, разыменовывание (через * и ->), а также операторы сравнения == и !=. Более подробно можно ознакомиться тут: http://www.cplusplus.com/reference/iterator/ForwardIterator/.
12) Ваш класс может инвалидировать все итераторы после вставок и удалений. Иными словами, если из таблицы удаляется или вставляется элемент, то все имеющиеся на данный момент итераторы могут стать недействительными. Стандартный std::unordered_map при вызове erase инвалидирует только итераторы на удаленный элемент, остальные итераторы остаются действительными.
13) Метод find, константный (возвращающий const_iterator) и нет (возвращающий iterator), который по переданному ключу возвращает итератор на соответствующую пару (ключ, значение), либо end(), если искомого ключа нет в таблице.
14) Оператор [ ], который по переданному ключу возвращает ссылку на соответствующее значение. Если же искомого ключа в таблице нет, то метод должен добавить в таблицу пару (ключ, значение по умолчанию) и вернуть соответствующую ссылку.
15) Константный метод at, который работает аналогично оператору [ ], но возвращает константную ссылку на значение, а при отсутствии ключа генерирует исключение типа std::out_of_range.
16) Метод clear, который очищает таблицу, удаляя все вставленные элементы. Обратите внимание, что метод должен работать за линейное время по количеству элементов в таблице.
17) Для сравнения ключей используйте только оператор ==.
